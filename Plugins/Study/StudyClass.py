import json
import base64
import pickle

from pathlib import Path
from typing import Dict, List
from httpx import AsyncClient
from datetime import datetime
from collections import defaultdict

from botConfig import GITHUB_TOKEN, PROXY
from nonebot.adapters.onebot.v11.message import Message

from Utils.MessageUtils import split_list
from Utils.CustumClass import Wordkbank, Ans, ReverseLib, ReverseItem

with open("./Resources/Json/wordbank.json", 'r', encoding="utf-8") as fr:
    studylib = Wordkbank.parse_raw(fr.read())
    print(id(studylib))

with open(Path(__file__).parent / "gist_id", "r+", encoding="utf-8") as f:
    gist_id = f.read()


PRE_COV_WORD = """
  | 响应词 | 应答时机 |
  |-----|-----|
"""


WORD_ITEM_DETALS = """
  - {}

    | 属性 | 值 |
    |-----|-----|
    | 响应词 | {} |
    | 创建者 | {} |
    | 添加时间 | {} |
    | 生效范围 | {} |"""


WORD_BANK_MARKDOWN_STR = """# 凛凛の词库（更新至{})

Tips: 个人私有词库 > 群组公有词库 > 全局公有词库


<details>
  <summary><h3>个人私有词库</h3></summary>
{}
</details>

<details>
  <summary><h3>群组公有词库</h3></summary>
{}
</details>


<details>
  <summary><h3>全局公有词库</h3></summary>
{}
</details>


<details>
  <summary><h3>预置欢迎词库</h3></summary>
{}
</details>


<details>
  <summary><h3>预置tome词库</h3></summary>
{}
</details>


<details>
  <summary><h3>预置poke词库</h3></summary>
{}
</details>
"""

class LibCmd:

    def __init__(self) -> None:
        self.mode:str = "kvat"
        self.keywd:str = ""
        self.result:List[List[Dict[str, List[ReverseItem]]]] = []

    @classmethod
    async def get_gist_link(cls, gist_id = gist_id) -> str:
        FRIEND_PRIVATE_WORDBANK = ""
        GROUP_PRIVATE_WORDBANK = ""
        GROUP_GLOBAL_WORDBANK = ""
        PRE_WELCOME_WORDBANK = ""
        PRE_TOME_WORDBANK = PRE_COV_WORD
        PRE_POKE_WORDBANK = PRE_COV_WORD
        headers = {
            "Authorization": f"Bearer {GITHUB_TOKEN}",
            "X-GitHub-Api-Version": "2022-11-28",
            "Accept": "application/vnd.github+json"
        }
        with open("./Resources/Json/wordbank.json", 'r', encoding="utf-8") as f:
            studylib = Wordkbank.parse_raw(f.read())

        for auth, v in studylib.friend.items():
            for keyword in v.__root__:
                for item in v.__root__[keyword]:
                    FRIEND_PRIVATE_WORDBANK += WORD_ITEM_DETALS.format(
                        keyword,
                        item.value,
                        item.auth,
                        item.time,
                        "Private: " + auth
                    )

        for group, v in studylib.group.items():
            for keyword in v.__root__:
                for item in v.__root__[keyword]:
                    if group == "global":
                        GROUP_GLOBAL_WORDBANK += WORD_ITEM_DETALS.format(
                            keyword,
                            item.value,
                            item.auth,
                            item.time,
                            "Group: " +group
                        )
                    else:
                        GROUP_PRIVATE_WORDBANK += WORD_ITEM_DETALS.format(
                            keyword,
                            item.value,
                            item.auth,
                            item.time,
                            group
                        )

        for welcome in studylib.preinstall.handle_new_member:
            PRE_WELCOME_WORDBANK += f"  {welcome}\n\n"

        for chance, v in studylib.preinstall.at_msg_reply.dict().items():
            for msg in v:
                PRE_TOME_WORDBANK += f"  | {chance} | {msg} |\n"

        for chance, v in studylib.preinstall.poke_msg_reply.dict().items():
            for msg in v:
                PRE_POKE_WORDBANK += f"  | {chance} | {msg} |\n"

        content = WORD_BANK_MARKDOWN_STR.format(
            datetime.now().strftime("%Y-%m-%d"),
            FRIEND_PRIVATE_WORDBANK,
            GROUP_PRIVATE_WORDBANK,
            GROUP_GLOBAL_WORDBANK,
            PRE_WELCOME_WORDBANK,
            PRE_TOME_WORDBANK,
            PRE_POKE_WORDBANK
        )

        post_data = {
            'description': 'This is the wordbank of SakuraiSenrin, generated by SakuraiSenrin',
            'public': True,
            'files': {
                'SakuraiSenrinWordBank.md': {
                    'content': content
                    }
            }
        }
        async with AsyncClient(proxies=PROXY) as Client:
            if gist_id:
                res = (await Client.post(f"https://api.github.com/gists/{gist_id}", headers=headers, json=post_data)).json()
            else:
                res = (await Client.post("https://api.github.com/gists", headers=headers, json=post_data)).json()
                gist_id = res['id']
                with open(Path(__file__).parent / "gist_id", "w+", encoding="utf-8") as f:
                    f.write(gist_id)
            return res['html_url']


    @classmethod
    def get_reverse_lib(cls, study_lib:Wordkbank) -> ReverseLib:
        ori_lib = study_lib.dict()
        del ori_lib["preinstall"]
        key_dict = defaultdict(list)
        auth_dict = defaultdict(list)
        time_dict = defaultdict(list)
        value_dict = defaultdict(list)

        for limit, limit_data in ori_lib.items():
            for effective_range, range_data in limit_data.items():
                for key, ans_list in range_data.items():
                    for ans in ans_list:
                        ans = Ans(**ans)

                        shuf_value = {
                            "key":key,
                            "auth":ans.auth,
                            "time":ans.time,
                            "limit":limit,
                            "value":ans.value,
                            "effective_range":effective_range
                        }

                        key_dict[key] += [shuf_value]
                        auth_dict[ans.auth] += [shuf_value]
                        time_dict[ans.time] += [shuf_value]
                        value_dict[ans.value] += [shuf_value]
        reverse_lib = ReverseLib.parse_obj({
            "k": dict(key_dict), 
            "a": dict(auth_dict), 
            "t": dict(time_dict) ,
            "v": dict(value_dict)
        })

        with open(Path(__file__).parent / "reverse_lib", "wb+") as f:
            pickle.dump(reverse_lib, f)

        return reverse_lib


    def checker(self, args:str):
        for x in args:
            if x not in self.mode:
                raise ValueError("[参数错误:mode]：搜索范围仅可为以下组合：\n  k（关键词模式）\n  v（应答语模式）\n  a（创建者模式）\n  t（时间序模式）\n例如：k, kva ka, kt等均为合法参数")
        else:
            if args:self.mode = args


    def lib_cmd_init(self, args:List[str]):
        if args:
            if keywd:=args[1:]:
                self.checker(args[0])
                self.keywd = " ".join(keywd)
            else:
                self.keywd = args[0]
            self.search()
        else:
            raise ValueError("[参数缺失:mode, keywd]：搜索范围仅可为以下组合：\n  k（关键词模式）\n  v（应答语模式）\n  a（创建者模式）\n  t（时间序模式）\n例如：k, kva ka, kt等均为合法参数\nkeywd为关键词，可通过仅提供mode进入交互模式")


    def search(self) -> None:
        final_dict = defaultdict(list)
        total_list = []
        for mode in self.mode:
            for key, value in getattr(reverse_lib, mode).__root__.items():
                final_dict[key].extend(value) 
        for k,v in dict(final_dict).items():
            if self.keywd in k:
                total_list.append({k:v})
        self.result = split_list(total_list, 80)
        ...


class StudyCmd:

    def __init__(self, dict_arg:Dict) -> None:
        self.model:str
        self.question:str
        self.answer:str
        self.block:str
        self.user_id:str
        self.key_id:str
        self.ans:Ans = Ans()
        for key,value in dict_arg.items():
            setattr(self, key, value)


    @classmethod
    async def study_command_init(cls, args:Message) -> "StudyCmd":
        arg_text_list = str(args).strip().split(" ")
        if (lenth:=len(arg_text_list)) > 4:
            raise TypeError(f"[参数错误:args]：最大传入数为4，已传入{lenth}\n提示：请勿在感知语和问答语中添加空格，如有需要请采用交互模式\n例如：直接发送#study进入交互模式")
        else:
            for i, arg in enumerate(arg_text_list):
                final_word = await cls.handleCQ(arg)
                arg_text_list[i] = final_word
            if arg_text_list == ['']:
                dict_args = {}
            else:
                dict_args = dict(zip(['model','block','question','answer'], arg_text_list))
        study_cmd = StudyCmd(dict_args)
        return study_cmd


    @classmethod
    async def handleCQ(cls, arg:str) -> str:
        final_word = ""
        for _arg in Message(arg.strip()):
            if _arg.type == 'image':
                async with AsyncClient() as Client:
                    pic_base = base64.b64encode((await Client.get(_arg.data['url'])).read()).decode()
                final_word += f"[CQ:image,file=base64://{pic_base}]"
            elif _arg.type in ['text', 'face']:
                final_word += str(_arg)
        return final_word


    def checker(self):
        if hasattr(self, "model"):            
            if self.model.lower() not in ['a', 'm']:raise ValueError(f"[参数错误:model]：model仅可为：\n  A（公共词库）\n  M（私人词库）\n当前参数：model={self.model[:7]}")
        if hasattr(self, "block"):
            if self.block.lower() not in ['t', 'f']:raise ValueError(f"[参数错误:block]：block仅可为：\n  T（开启隔离）\n  F（关闭隔离）\n当前参数：model={self.block[:7]}")


    def update(self, studylib:Wordkbank) -> Wordkbank:
        global reverse_lib
        studylib_dict = studylib.dict()
        self.model = self.model.lower()
        self.block = self.block.lower()

        self.ans.value = self.answer
        self.ans.auth = self.user_id
        self.ans.time = (datetime.now()).strftime('%Y-%m-%d')

        if self.model== 'a':
            self.model = 'group'
        else:
            self.model = 'friend'
            self.key_id = self.user_id

        if self.block == 'f' :
            self.key_id = 'global'

        temp_dict = studylib_dict[self.model]
        if self.key_id not in temp_dict:
            temp_dict[self.key_id] = {}
        del temp_dict

        if self.question not in studylib_dict[self.model][self.key_id]:
            studylib_dict[self.model][self.key_id][self.question] = []
        question_dict = studylib_dict[self.model][self.key_id][self.question]
        
        try:
            if (word:=self.ans.dict())['value'] not in [x['value'] for x in question_dict]:
                question_dict += [word]
            else:
                raise ValueError
        except ValueError:
            raise ValueError("该词条已存在，重复添加要挨揍哦？")
        except:
            question_dict = [self.ans.dict()]
        with open("./Resources/Json/wordbank.json", 'w+', encoding="utf-8") as f:
            json.dump(studylib_dict, f, sort_keys=True, indent=4, ensure_ascii=False)
        studylib = Wordkbank.parse_obj(studylib_dict)
        reverse_lib = LibCmd.get_reverse_lib(studylib)
        return studylib


try:
    with open(Path(__file__).parent / "reverse_lib", "rb+") as f:
        reverse_lib:ReverseLib = pickle.load(f)
except:
    reverse_lib = LibCmd.get_reverse_lib(studylib)